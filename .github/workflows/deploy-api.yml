name: Deploy API

# This workflow deploys the API to different environments based on branch:
# - Push to 'test' branch -> Deploy to test environment (same AWS account)
# - Push to 'main' branch -> Deploy to prod environment (same AWS account)
# - Manual workflow_dispatch -> Deploy to selected environment
#
# Required GitHub Secrets:
# - AWS_ROLE_ARN: IAM role for the single AWS account
# Note: Database passwords are retrieved from AWS Secrets Manager for test/prod
#
# Environment Protection Rules:
# Configure in GitHub Settings > Environments:
# - test: Optional approval, can be automatic
# - prod: Required approval from designated reviewers

on:
  push:
    branches:
      - test
      # - main - add back when prod ready
    paths:
      - 'apps/api/**'
      - 'packages/**'
      - '.github/workflows/deploy-api.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'test'
        type: choice
        options:
        - test
        - prod

concurrency:
  group: deploy-api-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: eu-west-3

jobs:
  # Determine environment based on branch
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/test" ]; then
            echo "environment=test" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "Unknown branch: ${{ github.ref }}"
            exit 1
          fi

  deploy:
    needs: determine-environment
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Generate image tags
      id: meta
      run: |
        ENVIRONMENT="${{ needs.determine-environment.outputs.environment }}"
        REPOSITORY_URI="${{ steps.login-ecr.outputs.registry }}/ashinaga-api-${ENVIRONMENT}"
        
        # Generate tags
        TAGS="${REPOSITORY_URI}:latest"
        TAGS="${TAGS},${REPOSITORY_URI}:${GITHUB_SHA::8}"
        TAGS="${TAGS},${REPOSITORY_URI}:${GITHUB_REF_NAME}-${GITHUB_SHA::8}"
        
        # Add timestamp tag
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        TAGS="${TAGS},${REPOSITORY_URI}:${TIMESTAMP}"
        
        echo "tags=${TAGS}" >> $GITHUB_OUTPUT
        echo "repository_uri=${REPOSITORY_URI}" >> $GITHUB_OUTPUT

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: apps/api/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Install PostgreSQL client
      run: |
        sudo apt-get update
        sudo apt-get install -y postgresql-client

    - name: Run database migrations
      run: |
        ENVIRONMENT="${{ needs.determine-environment.outputs.environment }}"
        
        echo "Getting database connection details..."
        
        # Get database connection details directly from AWS RDS
        DB_IDENTIFIER="ashinaga-postgres-${ENVIRONMENT}"
        
        DB_ENDPOINT=$(aws rds describe-db-instances \
          --db-instance-identifier ${DB_IDENTIFIER} \
          --query 'DBInstances[0].Endpoint.Address' \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$DB_ENDPOINT" ] || [ "$DB_ENDPOINT" = "None" ]; then
          echo "Cannot get database endpoint from AWS RDS. Please ensure infrastructure is deployed."
          echo "Looking for database with identifier: ${DB_IDENTIFIER}"
          aws rds describe-db-instances --query 'DBInstances[*].[DBInstanceIdentifier,DBInstanceStatus]' --output table || echo "Failed to list databases"
          exit 1
        fi
        
        # Get database connection details from RDS instance
        DB_HOST="$DB_ENDPOINT"
        DB_PORT=5432
        DB_NAME=$(aws rds describe-db-instances \
          --db-instance-identifier ${DB_IDENTIFIER} \
          --query 'DBInstances[0].DBName' \
          --output text)
        DB_USER=$(aws rds describe-db-instances \
          --db-instance-identifier ${DB_IDENTIFIER} \
          --query 'DBInstances[0].MasterUsername' \
          --output text)
        
        echo "Database host: ${DB_HOST}"
        echo "Database name: ${DB_NAME}"
        echo "Database user: ${DB_USER}"
        
        # Set up Node.js and pnpm for migrations
        echo "Setting up Node.js and pnpm..."
        
        # Install pnpm if not available
        if ! command -v pnpm &> /dev/null; then
          npm install -g pnpm
        fi
        
        # Install dependencies (only if package.json changed)
        pnpm install --frozen-lockfile
        
        # Database is now permanently publicly accessible for debugging purposes
        
        # Run migrations
        echo "Running database migrations..."
        cd apps/api
        
        # Set database environment variables
        export DB_HOST="$DB_HOST"
        export DB_PORT="$DB_PORT"
        export DB_NAME="$DB_NAME" 
        export DB_USER="$DB_USER"
        
        # Get database password from AWS Secrets Manager
        echo "Retrieving database password from AWS Secrets Manager..."
        SECRET_NAME="ashinaga-db-password-${ENVIRONMENT}"
        
        # Get the most recent secret ARN (in case there are duplicates)
        SECRET_ARN=$(aws secretsmanager list-secrets \
          --query "SecretList[?contains(Name, '${SECRET_NAME}')] | sort_by(@, &CreatedDate) | [-1].ARN" \
          --output text)
        
        if [ -z "$SECRET_ARN" ]; then
          echo "ERROR: Could not find secret with name containing: ${SECRET_NAME}"
          echo "Available secrets:"
          aws secretsmanager list-secrets --query "SecretList[].Name" --output table
          exit 1
        fi
        
        echo "Found secret: $SECRET_ARN"
        export DB_PASSWORD=$(aws secretsmanager get-secret-value \
          --secret-id "$SECRET_ARN" \
          --query SecretString --output text)
          
        # Get Better Auth secret from AWS Secrets Manager
        echo "Retrieving Better Auth secret from AWS Secrets Manager..."
        AUTH_SECRET_NAME="ashinaga-auth-secret-${ENVIRONMENT}"
        
        AUTH_SECRET_ARN=$(aws secretsmanager list-secrets \
          --query "SecretList[?contains(Name, '${AUTH_SECRET_NAME}')] | sort_by(@, &CreatedDate) | [-1].ARN" \
          --output text)
        
        if [ -z "$AUTH_SECRET_ARN" ]; then
          echo "ERROR: Could not find auth secret with name containing: ${AUTH_SECRET_NAME}"
          exit 1
        fi
        
        export BETTER_AUTH_SECRET=$(aws secretsmanager get-secret-value \
          --secret-id "$AUTH_SECRET_ARN" \
          --query SecretString --output text)

        # Get Resend API key from AWS Secrets Manager
        echo "Retrieving Resend API key from AWS Secrets Manager..."
        RESEND_SECRET_NAME="ashinaga-resend-api-key-${ENVIRONMENT}"

        RESEND_SECRET_ARN=$(aws secretsmanager list-secrets \
          --query "SecretList[?contains(Name, '${RESEND_SECRET_NAME}')] | sort_by(@, &CreatedDate) | [-1].ARN" \
          --output text)

        if [ -z "$RESEND_SECRET_ARN" ]; then
          echo "ERROR: Could not find Resend secret with name containing: ${RESEND_SECRET_NAME}"
          exit 1
        fi

        export RESEND_API_KEY=$(aws secretsmanager get-secret-value \
          --secret-id "$RESEND_SECRET_ARN" \
          --query SecretString --output text)

        # Set Better Auth URL based on environment
        if [ "$ENVIRONMENT" = "test" ]; then
          export BETTER_AUTH_URL="https://api-test.ashinaga-uk.org"
        else
          export BETTER_AUTH_URL="https://api.ashinaga-uk.org"
        fi

        # Set Frontend URLs based on environment
        if [ "$ENVIRONMENT" = "test" ]; then
          export STAFF_APP_URL="https://staff-test.ashinaga-uk.org"
          export SCHOLAR_APP_URL="https://scholar-test.ashinaga-uk.org"
        else
          export STAFF_APP_URL="https://staff.ashinaga-uk.org"
          export SCHOLAR_APP_URL="https://scholar.ashinaga-uk.org"
        fi
        
        # Run Drizzle migrations
        echo "Running Drizzle migrations with verbose output..."
        echo "Environment variables:"
        echo "NODE_ENV: $NODE_ENV"
        echo "DB_HOST: $DB_HOST"
        echo "DB_PORT: $DB_PORT"
        echo "DB_NAME: $DB_NAME"
        echo "DB_USER: $DB_USER"
        echo "BETTER_AUTH_URL: $BETTER_AUTH_URL"
        echo "BETTER_AUTH_SECRET: [MASKED]"
        echo "RESEND_API_KEY: [MASKED]"
        echo "STAFF_APP_URL: $STAFF_APP_URL"
        echo "SCHOLAR_APP_URL: $SCHOLAR_APP_URL"
        
        # Set SSL to production mode for RDS connection
        export NODE_ENV="production"
        
        # Run the migration
        pnpm db:migrate
        
        echo "Database migrations completed successfully!"

    - name: Update App Runner service
      run: |
        # This step:
        # 1. Fetches latest secrets from AWS Secrets Manager
        # 2. Builds App Runner configuration using jq (handles special characters)
        # 3. Updates App Runner with new image and fresh environment variables

        ENVIRONMENT="${{ needs.determine-environment.outputs.environment }}"
        SERVICE_NAME="ashinaga-api-${ENVIRONMENT}"
        IMAGE_URI="${{ steps.meta.outputs.repository_uri }}:latest"

        echo "Updating App Runner service: ${SERVICE_NAME}"
        echo "New image: ${IMAGE_URI}"

        # Get service ARN
        SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text)

        if [ -z "$SERVICE_ARN" ]; then
          echo "Service does not exist yet. Please run terraform apply first."
          exit 1
        fi

        # Fetch the latest secrets from AWS Secrets Manager
        echo "Fetching latest secrets from AWS Secrets Manager..."

        # Helper function to get secret value and trim whitespace
        get_secret_value() {
          local secret_pattern="$1"
          # Get the most recent secret ARN matching the pattern
          local secret_arn=$(aws secretsmanager list-secrets \
            --query "SecretList[?contains(Name, '${secret_pattern}')] | sort_by(@, &CreatedDate) | [-1].ARN" \
            --output text)

          if [ -z "$secret_arn" ] || [ "$secret_arn" = "None" ]; then
            echo "ERROR: Could not find secret with pattern: ${secret_pattern}" >&2
            echo "Available secrets:" >&2
            aws secretsmanager list-secrets --query "SecretList[].Name" --output table >&2
            return 1
          fi

          echo "Found secret: $secret_arn" >&2

          # Get secret value and trim whitespace
          aws secretsmanager get-secret-value \
            --secret-id "$secret_arn" \
            --query SecretString \
            --output text | xargs
        }

        # Fetch all secrets
        echo "Fetching database password..."
        DB_PASSWORD=$(get_secret_value "ashinaga-db-password-${ENVIRONMENT}")
        echo "Fetching auth secret..."
        BETTER_AUTH_SECRET=$(get_secret_value "ashinaga-auth-secret-${ENVIRONMENT}")
        echo "Fetching Resend API key..."
        RESEND_API_KEY=$(get_secret_value "ashinaga-resend-api-key-${ENVIRONMENT}")

        # Get database connection details
        echo "Getting database configuration..."
        DB_IDENTIFIER="ashinaga-postgres-${ENVIRONMENT}"
        DB_ENDPOINT=$(aws rds describe-db-instances \
          --db-instance-identifier ${DB_IDENTIFIER} \
          --query 'DBInstances[0].Endpoint.Address' \
          --output text)
        DB_NAME=$(aws rds describe-db-instances \
          --db-instance-identifier ${DB_IDENTIFIER} \
          --query 'DBInstances[0].DBName' \
          --output text)
        DB_USER=$(aws rds describe-db-instances \
          --db-instance-identifier ${DB_IDENTIFIER} \
          --query 'DBInstances[0].MasterUsername' \
          --output text)

        # Get S3 bucket name
        S3_BUCKET_NAME="ashinaga-scholar-data-${ENVIRONMENT}"

        # Set environment-specific values
        if [ "$ENVIRONMENT" = "test" ]; then
          NODE_ENV="test"
          BETTER_AUTH_URL="https://api-test.ashinaga-uk.org"
          CORS_ORIGINS="https://staff-test.ashinaga-uk.org,https://scholar-test.ashinaga-uk.org,http://localhost:4001,http://localhost:4002"
          STAFF_APP_URL="https://staff-test.ashinaga-uk.org"
          SCHOLAR_APP_URL="https://scholar-test.ashinaga-uk.org"
        else
          NODE_ENV="production"
          BETTER_AUTH_URL="https://api.ashinaga-uk.org"
          CORS_ORIGINS="https://staff.ashinaga-uk.org,https://scholar.ashinaga-uk.org,http://localhost:4001,http://localhost:4002"
          STAFF_APP_URL="https://staff.ashinaga-uk.org"
          SCHOLAR_APP_URL="https://scholar.ashinaga-uk.org"
        fi

        # Build the App Runner configuration JSON using jq for proper escaping
        echo "Building App Runner configuration..."
        APP_RUNNER_CONFIG=$(jq -n \
          --arg image_uri "$IMAGE_URI" \
          --arg node_env "$NODE_ENV" \
          --arg db_host "$DB_ENDPOINT" \
          --arg db_name "$DB_NAME" \
          --arg db_user "$DB_USER" \
          --arg db_password "$DB_PASSWORD" \
          --arg auth_secret "$BETTER_AUTH_SECRET" \
          --arg auth_url "$BETTER_AUTH_URL" \
          --arg cors_origins "$CORS_ORIGINS" \
          --arg resend_api_key "$RESEND_API_KEY" \
          --arg email_from "noreply@ashinaga-uk.org" \
          --arg staff_app_url "$STAFF_APP_URL" \
          --arg scholar_app_url "$SCHOLAR_APP_URL" \
          --arg s3_bucket "$S3_BUCKET_NAME" \
          --arg aws_region "$AWS_REGION" \
          '{
            "ImageRepository": {
              "ImageIdentifier": $image_uri,
              "ImageRepositoryType": "ECR",
              "ImageConfiguration": {
                "Port": "4000",
                "RuntimeEnvironmentVariables": {
                  "NODE_ENV": $node_env,
                  "PORT": "4000",
                  "DB_HOST": $db_host,
                  "DB_PORT": "5432",
                  "DB_NAME": $db_name,
                  "DB_USER": $db_user,
                  "DB_PASSWORD": $db_password,
                  "BETTER_AUTH_SECRET": $auth_secret,
                  "BETTER_AUTH_URL": $auth_url,
                  "CORS_ORIGINS": $cors_origins,
                  "RESEND_API_KEY": $resend_api_key,
                  "EMAIL_FROM": $email_from,
                  "STAFF_APP_URL": $staff_app_url,
                  "SCHOLAR_APP_URL": $scholar_app_url,
                  "S3_BUCKET_NAME": $s3_bucket,
                  "AWS_REGION": $aws_region
                }
              }
            },
            "AutoDeploymentsEnabled": true
          }')

        # Function to update App Runner service
        update_app_runner_service() {
          echo "Sending update request to App Runner..."
          aws apprunner update-service \
            --service-arn ${SERVICE_ARN} \
            --source-configuration "$APP_RUNNER_CONFIG"

          if [ $? -eq 0 ]; then
            echo "✅ Successfully triggered App Runner update with latest secrets"
          else
            echo "❌ Failed to update App Runner service"
            exit 1
          fi
        }

        # Check service status
        SERVICE_STATUS=$(aws apprunner describe-service --service-arn ${SERVICE_ARN} --query "Service.Status" --output text)
        echo "Current service status: ${SERVICE_STATUS}"

        case ${SERVICE_STATUS} in
          "RUNNING")
            echo "Service is running - updating configuration with latest secrets..."
            update_app_runner_service
            ;;
          "CREATE_FAILED"|"PAUSED"|"DELETE_FAILED")
            echo "Service is in failed state (${SERVICE_STATUS}). Manual intervention required."
            exit 1
            ;;
          "OPERATION_IN_PROGRESS")
            echo "Service has an operation in progress - waiting for completion..."
            # Wait up to 15 minutes for current operation to complete
            timeout 900 bash -c "
              while true; do
                STATUS=\$(aws apprunner describe-service --service-arn ${SERVICE_ARN} --query 'Service.Status' --output text)
                echo \"Current status: \$STATUS\"
                if [ \"\$STATUS\" = \"RUNNING\" ]; then
                  echo \"Service is now running!\"
                  break
                elif [ \"\$STATUS\" = \"CREATE_FAILED\" ] || [ \"\$STATUS\" = \"DELETE_FAILED\" ]; then
                  echo \"Service failed: \$STATUS\"
                  exit 1
                fi
                sleep 30
              done
            " || {
              echo "Timeout waiting for service operation to complete"
              exit 1
            }
            echo "Service is now ready - updating configuration with latest secrets..."
            update_app_runner_service
            ;;
          *)
            echo "Service is in ${SERVICE_STATUS} state - waiting for it to be ready..."
            # Wait up to 15 minutes for service to be ready
            timeout 900 bash -c "
              while true; do
                STATUS=\$(aws apprunner describe-service --service-arn ${SERVICE_ARN} --query 'Service.Status' --output text)
                echo \"Current status: \$STATUS\"
                if [ \"\$STATUS\" = \"RUNNING\" ]; then
                  echo \"Service is now running!\"
                  break
                elif [ \"\$STATUS\" = \"CREATE_FAILED\" ] || [ \"\$STATUS\" = \"DELETE_FAILED\" ]; then
                  echo \"Service failed to start: \$STATUS\"
                  exit 1
                fi
                sleep 30
              done
            " || {
              echo "Timeout waiting for service to be ready"
              exit 1
            }

            echo "Service is now ready - updating configuration with latest secrets..."
            update_app_runner_service
            ;;
        esac

    - name: Wait for deployment
      run: |
        ENVIRONMENT="${{ needs.determine-environment.outputs.environment }}"
        SERVICE_NAME="ashinaga-api-${ENVIRONMENT}"
        SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text)
        
        echo "Waiting for deployment to complete..."
        # Wait up to 20 minutes for deployment to complete
        timeout 1200 bash -c "
          while true; do
            STATUS=\$(aws apprunner describe-service --service-arn ${SERVICE_ARN} --query 'Service.Status' --output text)
            echo \"Current deployment status: \$STATUS\"
            if [ \"\$STATUS\" = \"RUNNING\" ]; then
              echo \"Deployment completed successfully!\"
              break
            elif [ \"\$STATUS\" = \"CREATE_FAILED\" ] || [ \"\$STATUS\" = \"DELETE_FAILED\" ]; then
              echo \"Deployment failed: \$STATUS\"
              exit 1
            fi
            sleep 30
          done
        " || {
          echo "Timeout waiting for deployment to complete"
          exit 1
        }
        
        # Get service URL
        SERVICE_URL=$(aws apprunner describe-service --service-arn ${SERVICE_ARN} --query "Service.ServiceUrl" --output text)
        echo "Deployment complete! Service available at: https://${SERVICE_URL}"
        
        # Add to job summary
        echo "## 🚀 Deployment Complete" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY  
        echo "- **Service URL**: https://${SERVICE_URL}" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: ${{ steps.meta.outputs.repository_uri }}:latest" >> $GITHUB_STEP_SUMMARY